# -*- coding: utf-8 -*-
"""202003692.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1l_QV6n4CPfZMrDKfuDXS9QCg5b5_weJC
"""

from googleapiclient.discovery import build

api_key = 'AIzaSyATJqMi0TvxvgQK-X4bkShS4nqeEjWV__U'
youtube = build('youtube', 'v3', developerKey=api_key)

# 채널 정보 가져오기 (사용자 이름으로 채널 찾기)
channel_id = 'UCoC-ZGuPCvJJrbcz9eMW8zw'
request = youtube.channels().list(part='snippet,statistics', id=channel_id)
response = request.execute()

# 채널 이름과 구독자 수 출력
channel_title = response['items'][0]['snippet']['title']
subscriber_count = response['items'][0]['statistics']['subscriberCount']
print(f"채널 이름: {channel_title}, 구독자 수: {subscriber_count}")

# 채널의 업로드된 동영상 목록 가져오기
playlist_request = youtube.channels().list(
    part='contentDetails',
    id=channel_id
)
playlist_response = playlist_request.execute()

# 업로드된 동영상의 playlistId 추출
uploads_playlist_id = playlist_response['items'][0]['contentDetails']['relatedPlaylists']['uploads']

# 동영상 목록 가져오기
video_request = youtube.playlistItems().list(
    part='snippet',
    playlistId=uploads_playlist_id,
    maxResults=50  # 한 번에 가져올 동영상 수 (최대 50개)
)
video_response = video_request.execute()

# 동영상 ID 목록 가져오기
video_ids = []
for item in video_response['items']:
    video_id = item['snippet']['resourceId']['videoId']
    video_ids.append(video_id)

# 동영상 통계 정보 가져오기
video_stats_request = youtube.videos().list(
    part='snippet,statistics',
    id=','.join(video_ids)  # 여러 개의 동영상 ID를 ','로 구분하여 전달
)
video_stats_response = video_stats_request.execute()

# 각 동영상의 제목, 조회수, 좋아요, 댓글 수 출력
for item in video_stats_response['items']:
    title = item['snippet']['title']
    stats = item['statistics']
    views = stats.get('viewCount', 0)
    likes = stats.get('likeCount', 0_

    comments = stats.get('commentCount', 0)
    print(f"제목: {title}")
    print(f"조회수: {views}, 좋아요 수: {likes}, 댓글 수: {comments}")
    print('-' * 40)

from datetime import datetime

# 채널의 업로드된 동영상 목록 가져오기
playlist_request = youtube.channels().list(
    part='contentDetails',
    id=channel_id
)
playlist_response = playlist_request.execute()

# 업로드된 동영상의 playlistId 추출
uploads_playlist_id = playlist_response['items'][0]['contentDetails']['relatedPlaylists']['uploads']

# 동영상 ID 목록을 저장할 리스트
video_ids = []

# 페이지네이션을 사용하여 모든 동영상 가져오기
next_page_token = None
while True:
    video_request = youtube.playlistItems().list(
        part='snippet',
        playlistId=uploads_playlist_id,
        maxResults=50,  # 한 번에 가져올 동영상 수 (최대 50개)
        pageToken=next_page_token  # 다음 페이지 요청 시 사용
    )
    video_response = video_request.execute()

    # 동영상 ID 추출
    for item in video_response['items']:
        video_id = item['snippet']['resourceId']['videoId']
        video_ids.append(video_id)

    # 다음 페이지가 있는지 확인
    next_page_token = video_response.get('nextPageToken')
    if not next_page_token:
        break  # 더 이상 페이지가 없으면 종료

# 동영상 조회수 및 업로드 날짜 가져오기
video_views_over_time = {}

# 각 동영상의 조회수 및 업로드 날짜 가져오기
for i in range(0, len(video_ids), 50):  # 최대 50개씩 가져오기
    video_batch = video_ids[i:i+50]

    video_stats_request = youtube.videos().list(
        part='snippet,statistics',
        id=','.join(video_batch)  # 50개씩 묶어서 요청
    )
    video_stats_response = video_stats_request.execute()

    # 조회수 추이를 기록할 변수
    for item in video_stats_response['items']:
        title = item['snippet']['title']
        video_id = item['id']
        stats = item['statistics']
        views = int(stats.get('viewCount', 0))
        upload_date = item['snippet']['publishedAt']

        # 업로드 날짜를 datetime 형식으로 변환
        upload_date = datetime.strptime(upload_date, "%Y-%m-%dT%H:%M:%S%z")

        # 조회수 기록
        if video_id not in video_views_over_time:
            video_views_over_time[video_id] = {'title': title, 'views': [], 'dates': []}

        # 조회수와 날짜 기록
        video_views_over_time[video_id]['views'].append(views)
        video_views_over_time[video_id]['dates'].append(upload_date)

# 조회수 변화 출력
for video_id, data in video_views_over_time.items():
    print(f"Video: {data['title']}")
    for date, view in zip(data['dates'], data['views']):
        print(f"Date: {date.strftime('%Y-%m-%d %H:%M:%S')}, Views: {view}")
    print('-' * 40)

# 동영상 통계 정보 및 좋아요 수 추가
video_data = []
for i in range(0, len(video_ids), 50):
    video_batch = video_ids[i:i + 50]
    video_stats_request = youtube.videos().list(
        part='snippet,statistics',
        id=','.join(video_batch)
    )
    video_stats_response = video_stats_request.execute()
    for item in video_stats_response['items']:
        title = item['snippet']['title']  # 제목을 정확히 가져옴
        video_id = item['id']
        stats = item['statistics']
        views = int(stats.get('viewCount', 0))
        likes = int(stats.get('likeCount', 0))
        comments = int(stats.get('commentCount', 0))
        upload_date = item['snippet']['publishedAt']
        upload_date = datetime.strptime(upload_date, "%Y-%m-%dT%H:%M:%S%z")
        video_data.append({
            "title": title,  # 동영상 제목 저장
            "video_id": video_id,
            "views": views,
            "likes": likes,
            "comments": comments,
            "upload_date": upload_date
        })

# DataFrame으로 변환
df = pd.DataFrame(video_data)

# 좋아요 수가 가장 많은 동영상 찾기
most_liked_video = df.loc[df['likes'].idxmax()]  # 'likes' 컬럼을 사용하여 가장 많은 좋아요 수를 찾음

# 가장 많은 좋아요를 받은 동영상 출력
print(f"가장 많은 좋아요를 받은 동영상:")
print(f"제목: {most_liked_video['title']}")
print(f"좋아요 수: {most_liked_video['likes']}")
print(f"업로드 날짜: {most_liked_video['upload_date']}")

from googleapiclient.discovery import build
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime

# 업로드된 동영상 목록 가져오기
playlist_request = youtube.channels().list(part='contentDetails', id=channel_id)
playlist_response = playlist_request.execute()
uploads_playlist_id = playlist_response['items'][0]['contentDetails']['relatedPlaylists']['uploads']

video_ids = []
next_page_token = None
while True:
    video_request = youtube.playlistItems().list(
        part='snippet',
        playlistId=uploads_playlist_id,
        maxResults=50,
        pageToken=next_page_token
    )
    video_response = video_request.execute()
    for item in video_response['items']:
        video_ids.append(item['snippet']['resourceId']['videoId'])
    next_page_token = video_response.get('nextPageToken')
    if not next_page_token:
        break

print(f"총 {len(video_ids)}개의 동영상")

# 동영상 통계 정보 및 좋아요 수 수집
video_data = []
for i in range(0, len(video_ids), 50):
    video_batch = video_ids[i:i + 50]
    video_stats_request = youtube.videos().list(
        part='snippet,statistics',
        id=','.join(video_batch)
    )
    video_stats_response = video_stats_request.execute()
    for item in video_stats_response['items']:
        title = item['snippet']['title']
        video_id = item['id']
        stats = item['statistics']
        likes = int(stats.get('likeCount', 0))
        upload_date = item['snippet']['publishedAt']
        upload_date = datetime.strptime(upload_date, "%Y-%m-%dT%H:%M:%S%z")
        video_data.append({
            "title": title,
            "video_id": video_id,
            "likes": likes,
            "upload_date": upload_date
        })

# 데이터프레임으로 변환
df = pd.DataFrame(video_data)
df['upload_date'] = pd.to_datetime(df['upload_date'])

# 좋아요 수 그래프 만들기
plt.figure(figsize=(10, 5))
plt.plot(df['upload_date'], df['likes'], marker='o', color='g')
plt.xlabel('Upload Date')
plt.ylabel('Likes Count')
plt.title('Likes Count Trend Over Time')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# 좋아요 수 데이터 출력
print("좋아요 수 데이터:")
print(df[['title', 'upload_date', 'likes']])

from googleapiclient.discovery import build
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime

# 업로드된 동영상 목록 가져오기
playlist_request = youtube.channels().list(part='contentDetails', id=channel_id)
playlist_response = playlist_request.execute()
uploads_playlist_id = playlist_response['items'][0]['contentDetails']['relatedPlaylists']['uploads']

video_ids = []
next_page_token = None
while True:
    video_request = youtube.playlistItems().list(
        part='snippet',
        playlistId=uploads_playlist_id,
        maxResults=50,
        pageToken=next_page_token
    )
    video_response = video_request.execute()
    for item in video_response['items']:
        video_ids.append(item['snippet']['resourceId']['videoId'])
    next_page_token = video_response.get('nextPageToken')
    if not next_page_token:
        break

print(f"총 {len(video_ids)}개의 동영상")

# 동영상 통계 정보 및 댓글 분석
video_data = []
for i in range(0, len(video_ids), 50):
    video_batch = video_ids[i:i + 50]
    video_stats_request = youtube.videos().list(
        part='snippet,statistics',
        id=','.join(video_batch)
    )
    video_stats_response = video_stats_request.execute()
    for item in video_stats_response['items']:
        title = item['snippet']['title']
        video_id = item['id']
        stats = item['statistics']
        views = int(stats.get('viewCount', 0))
        likes = int(stats.get('likeCount', 0))
        comments = int(stats.get('commentCount', 0))
        upload_date = item['snippet']['publishedAt']
        upload_date = datetime.strptime(upload_date, "%Y-%m-%dT%H:%M:%S%z")
        video_data.append({
            "title": title,
            "video_id": video_id,
            "views": views,
            "likes": likes,
            "comments": comments,
            "upload_date": upload_date
        })


# 데이터프레임으로 변환
df = pd.DataFrame(video_data)
df['upload_date'] = pd.to_datetime(df['upload_date'])

# 댓글 수 가져오기
def get_comment_count(video_id):
    comment_request = youtube.videos().list(
        part='statistics',
        id=video_id
    )
    comment_response = comment_request.execute()
    comment_count = comment_response['items'][0]['statistics'].get('commentCount', 0)
    return int(comment_count)

# 동영상과 댓글 수 수집
video_data = []
for video_id in video_ids:
    comment_count = get_comment_count(video_id)
    video_data.append({
        "title": video_id,  # video_id를 title로 변경
        "video_id": video_id,
        "comment_count": comment_count,
    })

# 데이터프레임으로 변환
df_comments = pd.DataFrame(video_data)

# 업로드 시간순으로 정렬
df_comments['upload_date'] = df_comments['video_id'].apply(lambda video_id: df.loc[df['video_id'] == video_id, 'upload_date'].values[0])
df_comments_sorted = df_comments.sort_values(by='upload_date')

# 동영상 인덱스 추가
df_comments_sorted['video_index'] = range(1, len(df_comments_sorted) + 1)



# 댓글 수의 증가 추이 그래프
plt.figure(figsize=(10, 5))
plt.plot(df_comments_sorted['video_index'], df_comments_sorted['comment_count'], marker='o')
plt.xlabel('Video Index')
plt.ylabel('Comment Count')
plt.title('Comment Count Trend by Upload Order')
plt.xticks([])
plt.tight_layout()
plt.show()


# 댓글 수 데이터 출력
print("댓글 수 데이터:")
print(df_comments_sorted[['video_index', 'comment_count']])

from googleapiclient.discovery import build
import pandas as pd
import matplotlib.pyplot as plt
from wordcloud import WordCloud
from datetime import datetime
from collections import Counter
from io import BytesIO
from PIL import Image

# 동영상 정보 가져오기
def get_video_data(channel_id):
    playlist_request = youtube.channels().list(part='contentDetails', id=channel_id)
    playlist_response = playlist_request.execute()
    uploads_playlist_id = playlist_response['items'][0]['contentDetails']['relatedPlaylists']['uploads']

    video_data = []
    next_page_token = None

    while True:
        video_request = youtube.playlistItems().list(
            part='snippet',
            playlistId=uploads_playlist_id,
            maxResults=50,
            pageToken=next_page_token
        )
        video_response = video_request.execute()
        for item in video_response['items']:
            video_id = item['snippet']['resourceId']['videoId']
            title = item['snippet']['title']
            published_at = datetime.strptime(item['snippet']['publishedAt'], "%Y-%m-%dT%H:%M:%S%z")
            video_data.append({'video_id': video_id, 'title': title, 'published_at': published_at})

        next_page_token = video_response.get('nextPageToken')
        if not next_page_token:
            break

    return pd.DataFrame(video_data)


# 워드클라우드 생성
font_path = '/usr/share/fonts/truetype/nanum/NanumGothic.ttf'

def generate_wordcloud(comments, title):
    wordcloud = WordCloud(font_path=font_path, width=800, height=400, background_color='white').generate(" ".join(comments))
    buffer = BytesIO()
    wordcloud.to_image().save(buffer, format="PNG")
    buffer.seek(0)
    img = Image.open(buffer)
    return img

# 댓글 가져오기
def get_comments(video_id, max_comments=50):
    comments = []
    next_page_token = None

    try:
        while len(comments) < max_comments:
            comment_request = youtube.commentThreads().list(
                part='snippet',
                videoId=video_id,
                maxResults=50,
                pageToken=next_page_token
            )
            comment_response = comment_request.execute()
            for item in comment_response.get('items', []):
                comment = item['snippet']['topLevelComment']['snippet']['textOriginal']
                comments.append(comment)
                if len(comments) >= max_comments:
                    break
            next_page_token = comment_response.get('nextPageToken')
            if not next_page_token:
                break
    except Exception as e:
        print(f"Error retrieving comments for video ID {video_id}: {e}")

    return comments

# 댓글 분석 함수 추가
stop_words = {"진짜", "너무", "넘", "아", "ㅋㅋㅋㅋ", "ㅋㅋㅋ", "ㅋㅋ", "ㅋ", "ㅎㅎ", "ㅎㅎㅎ", "ㅅㅂ", "ㅠㅠ", "ㅜㅜ", "ㅇㅇ"}
def analyze_comments(comments):
    """
    댓글에서 상위 단어를 추출하는 함수
    """
    words = " ".join(comments).split()
    # 불용어 제외
    filtered_words = [word for word in words if word not in stop_words and len(word) > 1]
    word_counts = Counter(filtered_words)
    return word_counts.most_common(10)

# 동영상 정보 가져오기
video_data = get_video_data(CHANNEL_ID)
video_data['comment_count'] = video_data['video_id'].apply(get_comment_count)
video_data.sort_values(by='published_at', inplace=True)

# 댓글이 가장 많은/적은 동영상 찾기
video_data_with_comments = video_data[video_data['comment_count'] > 0]
most_comments_video = video_data_with_comments.loc[video_data_with_comments['comment_count'].idxmax()]
least_comments_video = video_data_with_comments.loc[video_data_with_comments['comment_count'].idxmin()]

# 댓글 수집 및 워드클라우드 생성
print(f"댓글이 가장 많은 동영상: {most_comments_video['title']}")
most_comments = get_comments(most_comments_video['video_id'], max_comments=200)
most_wc_buffer = generate_wordcloud(most_comments, most_comments_video['title'])
plt.figure(figsize=(8, 8))
plt.imshow(most_wc_buffer, interpolation='bilinear')
plt.axis('off')
plt.show()

print(f"댓글이 가장 적은 동영상: {least_comments_video['title']}")
least_comments = get_comments(least_comments_video['video_id'], max_comments=10000)  # 모든 댓글 가져오기
least_wc_buffer = generate_wordcloud(least_comments, least_comments_video['title'])
plt.figure(figsize=(8, 8))
plt.imshow(least_wc_buffer, interpolation='bilinear')
plt.axis('off')
plt.show()

# 댓글 분석
print("가장 많은 동영상의 주요 단어 분석:")
analyzed_most = analyze_comments(most_comments)
for word, count in analyzed_most:
    print(f"{word}: {count}")

print("가장 적은 동영상의 주요 단어 분석:")
analyzed_least = analyze_comments(least_comments)
for word, count in analyzed_least:
    print(f"{word}: {count}")

